{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#sony-headphones-bluetooth-documentation","title":"Sony Headphones Bluetooth Documentation","text":"<p>This page is a collection of information about the Sony Headphones Bluetooth protocol. It is a work in progress and gets updated as we find out more about the protocol. If you have any information that you would like to add, please feel free to submit a pull request.</p> <p>Warning</p> <p>This documentation may contain errors or incorrect information. Use at your own risk. It represents our best understanding of the protocols at this time.</p>"},{"location":"#repository","title":"Repository","text":"<p>The repository for this documentation can be found here.</p>"},{"location":"#license","title":"License","text":"<p>This documentation falls under the public domain via the CC0 1.0 Universal license.</p>"},{"location":"Devices/LinkBuds%20S/","title":"Sony LinkBuds S","text":""},{"location":"Devices/LinkBuds%20S/#commands","title":"Commands","text":"<p>Info</p> <p>The words marked as <code>---- ---- ----</code> change on every request. Perhaps they are a counter or a nonce.</p> <p>Info</p> <p>Packets over 16 bytes are split into multiple packets within the same message. If none of the table columns change except for the payload, then the packets are part of the same message.</p> <p>The tables below show the packets sent and received for performing a given action. The tables are ordered by the time the Bluetooth messages were sent or received, with the first message at the top.</p>"},{"location":"Devices/LinkBuds%20S/#ambient-sound-control-amsc","title":"Ambient Sound Control (AmSC)","text":"Action Type Handle Length Payload (Hex Decimals) Enable Noise Cancelling L2CAP Send 0x000B 32 09EF 39FF 5A00 1C40 ---- ---- ---- 3E0C 0100 0000 0768 1701 0100 0014 A93C 2540 L2CAP Receive 14 0BEF 1200 FF5A 0009 40DF DA00 A59A AmSC Off L2CAP Send 0x000B 32 09EF 39FF 5A00 1C40 ---- ---- ---- 3E0C 0000 0000 0768 1701 0000 0014 A73C 2740"},{"location":"Protocol/Payload%20Identifier/","title":"Payload Identifier","text":"<p>Information</p> <p>The information on this page is incomplete.</p> <p>Requests issued by the official client have some sort of payload identifier. It has been observed that requests with length 25-32 bytes send this payload identifier.</p> <p>Let's look at an example, Base16 encoded L2CAP Payload:</p> <pre><code>09EF 2BFF 5A00 15F0 01C3 EAA4 0015 3E01\n</code></pre> <p>The fourth-to-last byte and third-to-last byte (<code>01C3 EAA4</code>) are the payload identifier. The first payload identifier byte is split into two smaller bytes, <code>01</code> and <code>C3</code>, giving us <code>01 C3 EAA4</code> as the payload identifier.</p>"},{"location":"Protocol/Payload%20Identifier/#calculating-the-payload-identifier","title":"Calculating the Payload Identifier","text":"<p>Investigation needed</p> <p>This entire section needs to be reworked. Apparently, the payload identifier is not quite calculated as described here.</p> <p>The starting value for the payload identifier is yet unknown. However, the pattern for calculating the payload identifier for the next request \\(Y\\) is known, given a previous payload identifier \\(X\\).</p> <p>For easier understanding, let's split our payload identifier </p> <p>\\(X\\) = <code>01 C3 EAA4</code></p> <p>into</p> <p>\\(X_1\\) = <code>01</code>, \\(X_2\\) = <code>C3</code> and \\(X_3\\) = <code>EAA4</code>.</p> <p>The payload identifier for the next request \\(Y\\) is calculated as follows: \\(Y = (X_1 + 1) \\circ (X_2 + 1) \\circ (X_3 - 2)\\)</p> <p>where \\(\\circ\\) is the concatenation operator.</p> <p>This means, \\(Y\\) would equal <code>02C4 EAA2</code> in our example.</p>"}]}
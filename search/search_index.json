{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#sony-headphones-bluetooth-documentation","title":"Sony Headphones Bluetooth Documentation","text":"<p>This page is a collection of information about the Sony Headphones Bluetooth protocol. It is a work in progress and gets updated as we find out more about the protocol. If you have any information that you would like to add, please feel free to submit a pull request.</p> <p>Warning</p> <p>This documentation may contain errors or incorrect information. Use at your own risk. It represents our best understanding of the protocols at this time.</p>"},{"location":"#repository","title":"Repository","text":"<p>The repository for this documentation can be found here.</p>"},{"location":"#license","title":"License","text":"<p>This documentation falls under the public domain via the CC0 1.0 Universal license.</p>"},{"location":"Devices/LinkBuds%20S/","title":"Sony LinkBuds S","text":""},{"location":"Devices/LinkBuds%20S/#commands","title":"Commands","text":"<p>Warning</p> <p>The data here is not yet fully understood. This simply what we know at the moment. Use this information at your own risk.</p> <p>Info: About the Protocol</p> <p>RFCOMM over L2CAP is used for communication between the LinkBuds S and the host device. If you are capturing Bluetooth packets, you will see the full RFCOMM data, not just the data payload. Read more about the data structure of RFCOMM frames.</p> <p>Note</p> <p>The italicized text in the tables below is data which is inconsistent between packets. Until this data is understood, it is being referred to as \"Weird Bytes\" and might as well be random.</p> <p>Note</p> <p>The \"RFCOMM Data\" does not include the Address-, Control-, Length- and FCS-Bytes of the RFCOMM frame. It only includes the data payload.</p> <p>The tables below show the data packets sent and received for performing a given action.</p>"},{"location":"Devices/LinkBuds%20S/#ambient-sound-control-amsc","title":"Ambient Sound Control (AmSC)","text":"Action Length (L2CAP) \"Weird Bytes\" \"RFCOMM Data\" Payload Ambient Sound Control Off 32 39FF 5A 40 BEDE EAC5 0027 3E0C 0000 0000 0768 1701 0000 0008 9B3C 29 Noise Cancelling On 32 39FF 5A 40 ECE1 EA44 0029 3E0C 0100 0000 0768 1701 0100 0008 9D3C 23 Ambient Sound: 1 32 39FF 5A 40 6005 EAFC 0029 3E0C 0000 0000 0768 1701 0101 0001 963C 31 Ambient Sound: 2 32 39FF 5A 40 6005 EAFC 0029 3E0C 0000 0000 0768 1701 0101 0002 983C 31 Ambient Sound: 3 32 39FF 5A 40 6005 EAFC 0029 3E0C 0000 0000 0768 1701 0101 0003 983C 31"},{"location":"Devices/LinkBuds%20S/#speak-to-chat","title":"Speak to Chat","text":"Action Length (L2CAP) \"Weird Bytes\" \"RFCOMM Data\" Payload Toggle On 29 33FF 5A 40 AAE1 EAD9 002A 0100 0000 04F8 0C00 0116 3C Toggle Off 29 33FF 5A 40 AEE5 EAD1 002A 0000 0000 04F8 0C01 0116 3C <p>Ambient Sound Levels</p> <p>Ambient Sound levels go up to 20. To represent the values 4 to 20, set the bytes which were 0x0001, 0x0002 and 0x0003 for levels 1 to 3 respectively to the desired level in hexadecimal. For example, to set the level to 4, set the bytes to 0x0004. To set the level to 20, set the bytes to 0x0014, etc..</p>"},{"location":"Protocol/Specification/","title":"Specification","text":"<p>The protocol uses RFCOMM-like protocols on top of L2CAP to communicate over Bluetooth.</p> <p>Note</p> <p>The protocol used here seems to be a custom protocol, built on RFCOMM.</p> <p>The packages consist of a header, a data section and a Frame Check Sequence (FCS).</p> Position in Bits Name 1-8 Address 9-16 Control 17-40 ??? 25-32 Length Data (0 - 32767 Bytes) Last 8 Bits Frame Check Sequence (FCS) <p>Note</p> <p>\"8 bit\" means eight binary numbers. 4 binary numbers are equivalent to 1 hexadecimal number, so 8 bit are 2 hexadecimal digits.</p> <p>Looking at an examplary Data Capture, we can see which part of the frame is what:</p> <pre><code>09EF 39FF 5A00 1C40 F019 EA58 0024 3E0C\n0000 0000 0768 1701 0100 0014 A83C 1240 \n</code></pre> Data (Hex) RFCOMM Frame Part <code>09</code> Address (<code>0x09</code> in binary is <code>0000 1001</code>, signaling 2 Address fields. See: Extend Address Field) <code>EF</code> Control <code>39FF 5A</code> ??? \"Weird Bytes\" <code>001C</code> Length <code>40 F019 EA58 0024 3E0C 0000 0000 0768 1701 0100 0014 A83C 12</code> Data <code>40</code> FCS"},{"location":"Protocol/Specification/#extend-address-field","title":"Extend Address Field","text":"<p>The Extend Address (EA) field can extend the address or length fields. To calculate whether the fields will be extended by 8 more bits or not, we need to convert the field from hexadecimal to binary.</p> <p><code>F3E4</code> (Base16) = <code>1111001111100100</code>(Base2)</p> <p>The first bit is the EA bit. If it is set to 0, then extension will occur. If it is set to 1, then no extension will occur.</p>"},{"location":"Protocol/Specification/#extension-of-fields","title":"Extension of Fields","text":"<p>Address Field</p> <p>If EA=0 for the address fields, then more address octets will follow. If EA=1, then the field we are looking at is the last address octet.</p> <p>Length Field</p> <p>If EA=0 for the length field, then the EA bit will be followed by 15 bits of length. If EA=1, then only 7 bits of length will follow.</p>"},{"location":"Protocol/Specification/#reference","title":"Reference","text":"<ul> <li>RFCOMM Spec: https://web.archive.org/web/20231022193147/https://ptgmedia.pearsoncmg.com/imprint_downloads/informit/bookreg/9780130661067/cr_ch10.pdf</li> </ul>"}]}